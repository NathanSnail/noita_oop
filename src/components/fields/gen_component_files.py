from dataclasses import dataclass
import pathlib

COMP_DOCS = pathlib.PosixPath(
    "~/.local/share/Steam/steamapps/common/Noita/tools_modding/component_documentation.txt"
).expanduser()
OUT_DIR = pathlib.Path("./src/components/fields/")


@dataclass
class ComponentField:
    ty: str
    default: str
    comment: str


def normalise_types(ty: str) -> str:
    remaps = {
        "int": "integer",
        "bool": "boolean",
        "float": "number",
        "double": "number",
        "std::string": "string",
        "vec2": "Vec2",
        "ivec2": "Vec2",
        "int32": "integer",
        "uint32": "integer",
        "uint32_t": "integer",
        "int64": "integer",
        "uint64": "integer",
        "int16": "integer",
        "uint16": "integer",
    }
    lens = "LensValue<"
    if ty[: len(lens)] == lens:
        return normalise_types(ty[len(lens) : -1])
    unsigned = "unsigned"
    if ty[: len(unsigned)] == unsigned:
        return normalise_types(ty[len(unsigned) :])
    if ty in remaps:
        return remaps[ty]
    return ty


def get_types(src: str) -> dict[str, dict[str, str]]:
    lines = src.split("\n")
    content = {
        "ParticleEmitterComponent": {
            "custom_style": "PARTICLE_EMITTER_CUSTOM_STYLE::Enum",
            "m_cached_image_animation": "ParticleEmitter_Animation*",
        },
        "ExplosionComponent": {"trigger": "EXPLOSION_TRIGGER_TYPE::Enum"},
        "InventoryComponent": {"update_listener": "InvenentoryUpdateListener*"},
        "PathFindingComponent": {
            "job_result_receiver": "MSG_QUEUE_PATH_FINDING_RESULT"
        },
        "MoveToSurfaceOnCreateComponent": {"type": "MOVETOSURFACE_TYPE::Enum"},
        "NinjaRopeComponent": {"mSegments": "NINJA_ROPE_SEGMENT_VECTOR"},
        "PathFindingComponent": {
            "mState": "PathFindingComponentState::Enum",
            "job_result_receiver": "MSG_QUEUE_PATH_FINDING_RESULT",
        },
        "TeleportComponent": {"state": "TeleportComponentState::Enum"},
    }
    content_items = [v2 for _, v in content.items() for _, v2 in v.items()]

    error = "error!"
    name = error
    for line in lines:
        if line == "":
            continue
        if line[0] != " ":
            name = line
            if name not in content.keys():
                content[name] = {}
            continue
        if line[1] == "-":
            continue
        if line[27] != " ":
            good = False
            for item in content_items:
                if item in line:
                    good = True
                    break
            if not good:
                raise Exception("error missing seperator", line)
            continue
        ty = "".join([x for x in line[:27].split(" ") if x != ""])
        field = line[28:].split(" ")[0]
        assert name != error, "Missing component name"
        content[name][field] = normalise_types(ty)
    return content


components = get_types(open(COMP_DOCS, "r").read())


def gen_special_component_fields():
    basic_types = set(["integer", "boolean", "number", "string"])
    out_file = """-- WARN: THIS FILE IS AUTOGENERATED - SEE `./src/components/fields/gen_component_files.py`
    return {
    """
    for component, fields in components.items():
        out_file += f"\t{component} = {{\n"
        empty = True
        for field, ty in fields.items():
            if ty not in basic_types:
                empty = False
                out_file += f'\t\t{field} = "{ty}",\n'
        if empty:
            out_file = out_file[:-1] + "},\n"
        else:
            out_file += "\t},\n"
    out_file += "}\n"

    open(OUT_DIR / "special_component_fields.lua", "w").write(out_file)


def gen_component_type(component_ty: str) -> str:
    components_ty = f"{component_ty}s"
    partial_ty = f"{component_ty}.partial"
    key_ty = f"{component_ty}.field"

    component_partial = f"---@class (exact) {partial_ty}"
    component_full = f"---@class (exact) {component_ty} : Component"
    fields = f"---@alias {key_ty}"

    for field, ty in components[component_ty].items():
        component_partial += f"\n---@field {field} {ty}?"
        component_full += f"\n---@field {field} {ty}"
        fields += f"\n---| '\"{field}\"' {ty}"

    return f"""---@class (exact) {components_ty}
---@overload fun(): {component_ty}
---@field enabled fun(self: {components_ty}, enabled: boolean): {components_ty}
---@field tagged fun(self: {components_ty}, tag: string): {components_ty}
---@field with_field fun(self: {components_ty}, field: {key_ty}, value: any): {components_ty}
---@field add fun(self: {components_ty}, fields: {partial_ty}): {component_ty}

{component_partial}

{component_full}

{fields}"""


def gen_component_types():
    types = "\n\n".join(
        gen_component_type(component_ty) for component_ty in components.keys()
    )

    open(OUT_DIR / "component_types.lua", "w").write(types)


gen_special_component_fields()
gen_component_types()
