from dataclasses import dataclass
import pathlib
from typing import Optional

COMP_DOCS = pathlib.PosixPath(
    "~/.local/share/Steam/steamapps/common/Noita/tools_modding/component_documentation.txt"
).expanduser()
OUT_DIR = pathlib.Path("./src/components/fields/")

warn = "-- WARN: THIS FILE IS AUTOGENERATED - SEE `./src/components/fields/gen_component_files.py`"


@dataclass
class ComponentField:
    ty: str
    default: str
    range: str
    comment: str


def normalise_types(ty: str) -> str:
    remaps = {
        "int": "integer",
        "bool": "boolean",
        "float": "number",
        "double": "number",
        "std::string": "string",
        "std_string": "string",
        "USTRING": "string",
        "vec2": "Vec2",
        "ivec2": "Vec2",
        "int32": "integer",
        "uint32": "integer",
        "uint32_t": "integer",
        "int64": "integer",
        "uint64": "integer",
        "int16": "integer",
        "uint16": "integer",
        "VECTOR_STR": "std::vector<std::string>",
        "VECTOR_STRING": "std::vector<std::string>",
        "VECTOR_ENTITYID": "std::vector<EntityID>",
        "VEC_ENTITY": "std::vector<EntityID>",
        "VECTOR_INT": "std::vector<int>",
        "VECTOR_INT32": "std::vector<int>",
        "VECTOR_FLOAT": "std::vector<float>",
        "b2Vec2": "Vec2",
    }
    lens = "LensValue<"
    if ty[: len(lens)] == lens:
        return normalise_types(ty[len(lens) : -1])
    unsigned = "unsigned"
    if ty[: len(unsigned)] == unsigned:
        return normalise_types(ty[len(unsigned) :])
    if ty in remaps:
        return remaps[ty]
    return ty


def get_types(src: str) -> dict[str, dict[str, ComponentField]]:
    lines = src.split("\n")
    basic_content = {
        "ParticleEmitterComponent": {
            "custom_style": "PARTICLE_EMITTER_CUSTOM_STYLE::Enum",
            "m_cached_image_animation": "ParticleEmitter_Animation*",
        },
        "ExplosionComponent": {"trigger": "EXPLOSION_TRIGGER_TYPE::Enum"},
        "InventoryComponent": {"update_listener": "InvenentoryUpdateListener*"},
        "PathFindingComponent": {
            "job_result_receiver": "MSG_QUEUE_PATH_FINDING_RESULT"
        },
        "MoveToSurfaceOnCreateComponent": {"type": "MOVETOSURFACE_TYPE::Enum"},
        "NinjaRopeComponent": {"mSegments": "NINJA_ROPE_SEGMENT_VECTOR"},
        "PathFindingComponent": {
            "mState": "PathFindingComponentState::Enum",
            "job_result_receiver": "MSG_QUEUE_PATH_FINDING_RESULT",
        },
        "TeleportComponent": {"state": "TeleportComponentState::Enum"},
    }
    components = {
        component: {field_name: ComponentField(field_ty, "", "", "")}
        for component, fields in basic_content.items()
        for field_name, field_ty in fields.items()
    }
    content_items = [(k, v2) for _, v in basic_content.items() for k, v2 in v.items()]

    error = "error!"
    name = error
    for line in lines:
        if line == "":
            continue
        if line[0] != " ":
            name = line
            if name not in components.keys():
                components[name] = {}
            continue
        if line[1] == "-":
            continue
        special = False
        if line[27] != " ":
            matching_item: Optional[tuple[str, str]] = None
            for item in content_items:
                if item[1] in line:
                    matching_item = item
                    break
            if matching_item is None:
                raise Exception("error missing seperator", line)
            field_name = matching_item[0]
            ty = matching_item[1]
            special = True
        else:
            ty = "".join([x for x in line[:27].split(" ") if x != ""])
            field_name = line[28:].split(" ")[0]
        assert name != error, "Missing component name"
        default_offset = 92
        if special:
            default_offset += len(ty) - 27 + 3
        ty = normalise_types(ty)
        default = line[default_offset:].split(" ")[0]
        remainder = line[default_offset + len(default) + 1 :]
        remainder = remainder.lstrip()

        if default == "-":
            default = ""

        if remainder[0] == "[":
            val_range = remainder.split("]")[0] + "]"
            comment = remainder[len(val_range) :].lstrip()
        else:
            val_range = ""
            comment = remainder

        if ty == "string":
            val_range = ""
            if len(default) > 0 and default[0] != '"':
                default = f'"{default}"'

        comment = comment[1:-1]
        if comment == "TODO: Comment":
            comment = ""

        components[name][field_name] = ComponentField(ty, default, val_range, comment)

    permitted_types = set(["number", "integer", "string", "boolean", "Vec2"])
    # these need to get turned into a lua type
    unimplemeted_types = set(
        [
            "ValueRange",
            "PARTICLE_EMITTER_CUSTOM_STYLE::Enum",
            "EXPLOSION_TRIGGER_TYPE::Enum",
            "ConfigExplosion",
            "MOVETOSURFACE_TYPE::Enum",  # this component seemingly gets deleted instantly? might be able to construct with an enum value
            "ENTITY_VEC",
            "types::aabb",
            "ConfigGun",
            "ConfigGunActionInfo",
            "EntityTags",
            "EntityID",
            "ARC_TYPE::Enum",
            "DAMAGE_TYPES::Enum",
            "types::xform",
            "AudioSourceHandle",
            "VEC_OF_MATERIALS",
            "ConfigDamagesByType",
            "RAGDOLL_FX::Enum",
            "std::vector<int>",  # TODO: sometimes these are material ids
            "std::vector<float>",
            "EntityTypeID",
            "ConfigDrugFx",
            "std::vector<std::string>",
            "std::vector<EntityID>",
            "GAME_EFFECT::Enum",
            "VISITED_VEC",
            "HIT_EFFECT::Enum",
            "INVENTORY_KIND::Enum",
            "ConfigLaser",
            "ValueRangeInt",
            "LUA_VM_TYPE::Enum",
            "MATERIAL_VEC_DOUBLES",
            "types::iaabb",
            "JOINT_TYPE::Enum",
            "Vec2ArrayInline",
            "ConfigDamageCritical",
            "PROJECTILE_TYPE::Enum",
            "types::fcolor",
            "SpriteStainsState",
            "VERLET_TYPE::Enum",
            "FloatArrayInline",
        ]
    )
    permitted_types = permitted_types.union(unimplemeted_types)
    # cannot be interacted with from lua
    banned_types = set(
        [
            "INVENTORYITEM_VECTOR",
            "MSG_QUEUE_PATH_FINDING_RESULT",
            "VECTOR_JUMPPARAMS",
            "PathFindingInput",
            "VECTOR_PATHNODE",
            "PathFindingResultNode",
            "PathFindingNodeHandle",
            "PathFindingComponentState::Enum",
            "NINJA_ROPE_SEGMENT_VECTOR",
            "TeleportComponentState::Enum",
            "AI_STATE_STACK",
            "RtsUnitGoal",
            "CharacterStatsModifier",
            "StatusEffectType",
            "IKLimbAttackerState",
            "IKLimbStateVec",
            "std::set<int32>",
            "ValueMap",
            "b2ObjectID",
            "ProjectileTriggers",
            "STACK_ANIMATIONSTATE",
            "ComponentTags",
            "VirtualTextureHandle",
            "UintArrayInline",
            "VerletLinkArrayInline",
            "MAP_STRING_STRING",
            "VEC_PENDINGPORTAL",
            "VEC_NPCPARTY",
            "VEC_CUTTHROUGHWORLD",
            "WormPartPositions",
        ]
    )

    for component_name, component in components.items():
        delete = []
        for field_name, field in component.items():
            if field.ty in banned_types or field.ty[-1] == "*":
                delete.append(field_name)
                continue
            assert (
                field.ty in permitted_types
            ), f"Bad type {field.ty} for {component_name}::{field_name}"
        for field_name in delete:
            component.pop(field_name)
    return components


components = get_types(open(COMP_DOCS, "r").read())


def gen_special_component_fields():
    basic_types = set(["integer", "boolean", "number", "string"])
    out_file = f"""{warn}
return {{
"""
    for component, fields in components.items():
        out_file += f"\t{component} = {{\n"
        empty = True
        for field, ty in fields.items():
            if ty.ty not in basic_types:
                empty = False
                out_file += f'\t\t{field} = "{ty.ty}",\n'
        if empty:
            out_file = out_file[:-1] + "},\n"
        else:
            out_file += "\t},\n"
    out_file += "}\n"

    open(OUT_DIR / "special_component_fields.lua", "w").write(out_file)


def gen_component_type(component_ty: str) -> str:
    components_ty = f"{component_ty}s"
    partial_ty = f"{component_ty}.partial"
    key_ty = f"{component_ty}.field"

    field_collection = components[component_ty]

    empty = len(field_collection) == 0

    component_partial = f"---@class (exact) {partial_ty}"
    component_full = f"---@class (exact) {component_ty} : Component"
    fields = f"---@alias {key_ty}" if not empty else ""

    for field, ty in field_collection.items():
        suffix = f"{f"`{field} = {ty.default}{f" {ty.range}" if ty.range != "" else ""}` " if ty.default != "" else ""}{ty.comment}"
        suffix_typed = (
            f"`{ty.ty} {suffix[1:]}"
            if len(suffix) > 0 and suffix[0] == "`"
            else f"`{ty.ty}` {suffix}"
        )
        component_partial += f"\n---@field {field} {ty.ty}? {suffix}".rstrip()
        component_full += f"\n---@field {field} {ty.ty} {suffix}".rstrip()
        fields += f"\n---| '\"{field}\"' {suffix_typed}".rstrip()

    return f"""---@class (exact) {components_ty}
---@overload fun(): {component_ty}
---@field enabled fun(self: {components_ty}, enabled: boolean): {components_ty}
---@field tagged fun(self: {components_ty}, tag: string): {components_ty}
{f"---@field with_field fun(self: {components_ty}, field: {key_ty}, value: any): {components_ty}" if not empty else ""}
---@field add fun(self: {components_ty}, fields: {partial_ty}?): {component_ty}

{component_partial}

{component_full}

{fields}"""


def gen_component_types():
    types = f"{warn}\n\n" + "\n\n".join(
        gen_component_type(component_ty) for component_ty in components.keys()
    )

    open(OUT_DIR / "component_types.lua", "w").write(types)


gen_special_component_fields()
gen_component_types()
