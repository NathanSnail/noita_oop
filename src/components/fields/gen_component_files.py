from dataclasses import dataclass
import pathlib
from typing import Optional

COMP_DOCS = pathlib.PosixPath(
    "~/.local/share/Steam/steamapps/common/Noita/tools_modding/component_documentation.txt"
).expanduser()
OUT_DIR = pathlib.Path("./src/components/fields/")


@dataclass
class ComponentField:
    ty: str
    default: str
    range: str
    comment: str


def normalise_types(ty: str) -> str:
    remaps = {
        "int": "integer",
        "bool": "boolean",
        "float": "number",
        "double": "number",
        "std::string": "string",
        "vec2": "Vec2",
        "ivec2": "Vec2",
        "int32": "integer",
        "uint32": "integer",
        "uint32_t": "integer",
        "int64": "integer",
        "uint64": "integer",
        "int16": "integer",
        "uint16": "integer",
    }
    lens = "LensValue<"
    if ty[: len(lens)] == lens:
        return normalise_types(ty[len(lens) : -1])
    unsigned = "unsigned"
    if ty[: len(unsigned)] == unsigned:
        return normalise_types(ty[len(unsigned) :])
    if ty in remaps:
        return remaps[ty]
    return ty


def get_types(src: str) -> dict[str, dict[str, ComponentField]]:
    lines = src.split("\n")
    basic_content = {
        "ParticleEmitterComponent": {
            "custom_style": "PARTICLE_EMITTER_CUSTOM_STYLE::Enum",
            "m_cached_image_animation": "ParticleEmitter_Animation*",
        },
        "ExplosionComponent": {"trigger": "EXPLOSION_TRIGGER_TYPE::Enum"},
        "InventoryComponent": {"update_listener": "InvenentoryUpdateListener*"},
        "PathFindingComponent": {
            "job_result_receiver": "MSG_QUEUE_PATH_FINDING_RESULT"
        },
        "MoveToSurfaceOnCreateComponent": {"type": "MOVETOSURFACE_TYPE::Enum"},
        "NinjaRopeComponent": {"mSegments": "NINJA_ROPE_SEGMENT_VECTOR"},
        "PathFindingComponent": {
            "mState": "PathFindingComponentState::Enum",
            "job_result_receiver": "MSG_QUEUE_PATH_FINDING_RESULT",
        },
        "TeleportComponent": {"state": "TeleportComponentState::Enum"},
    }
    content = {
        component: {field_name: ComponentField(field_ty, "", "", "")}
        for component, fields in basic_content.items()
        for field_name, field_ty in fields.items()
    }
    content_items = [(k, v2) for _, v in basic_content.items() for k, v2 in v.items()]

    error = "error!"
    name = error
    for line in lines:
        if line == "":
            continue
        if line[0] != " ":
            name = line
            if name not in content.keys():
                content[name] = {}
            continue
        if line[1] == "-":
            continue
        special = False
        if line[27] != " ":
            matching_item: Optional[tuple[str, str]] = None
            for item in content_items:
                if item[1] in line:
                    matching_item = item
                    break
            if matching_item is None:
                raise Exception("error missing seperator", line)
            field = matching_item[0]
            ty = matching_item[1]
            special = True
        else:
            ty = "".join([x for x in line[:27].split(" ") if x != ""])
            field = line[28:].split(" ")[0]
        assert name != error, "Missing component name"
        normalised = normalise_types(ty)
        default_offset = 92
        if special:
            default_offset += len(ty) - 27 + 3
        default = line[default_offset:].split(" ")[0]
        remainder = line[default_offset + len(default) + 1 :]
        remainder = remainder.lstrip()

        if default == "-":
            default = ""

        if remainder[0] == "[":
            val_range = remainder.split("]")[0] + "]"
            comment = remainder[len(val_range) :].lstrip()
        else:
            val_range = ""
            comment = remainder

        comment = comment[1:-1]
        if comment == "TODO: Comment":
            comment = ""

        content[name][field] = ComponentField(normalised, default, val_range, comment)
    return content


components = get_types(open(COMP_DOCS, "r").read())


def gen_special_component_fields():
    basic_types = set(["integer", "boolean", "number", "string"])
    out_file = """-- WARN: THIS FILE IS AUTOGENERATED - SEE `./src/components/fields/gen_component_files.py`
return {
"""
    for component, fields in components.items():
        out_file += f"\t{component} = {{\n"
        empty = True
        for field, ty in fields.items():
            if ty.ty not in basic_types:
                empty = False
                out_file += f'\t\t{field} = "{ty.ty}",\n'
        if empty:
            out_file = out_file[:-1] + "},\n"
        else:
            out_file += "\t},\n"
    out_file += "}\n"

    open(OUT_DIR / "special_component_fields.lua", "w").write(out_file)


def gen_component_type(component_ty: str) -> str:
    components_ty = f"{component_ty}s"
    partial_ty = f"{component_ty}.partial"
    key_ty = f"{component_ty}.field"

    field_collection = components[component_ty]

    empty = len(field_collection) == 0

    component_partial = f"---@class (exact) {partial_ty}"
    component_full = f"---@class (exact) {component_ty} : Component"
    fields = f"---@alias {key_ty}" if not empty else ""

    for field, ty in field_collection.items():
        suffix = f"{f"`{field} = {ty.default} {ty.range}` " if ty.default != "" else ""}{ty.comment}"
        suffix_typed = (
            f"`{ty.ty} {suffix[1:]}"
            if len(suffix) > 0 and suffix[0] == "`"
            else f"`{ty.ty}` {suffix}"
        )
        component_partial += f"\n---@field {field} {ty.ty}? {suffix}".rstrip()
        component_full += f"\n---@field {field} {ty.ty} {suffix}".rstrip()
        fields += f"\n---| '\"{field}\"' {suffix_typed}".rstrip()

    return f"""---@class (exact) {components_ty}
---@overload fun(): {component_ty}
---@field enabled fun(self: {components_ty}, enabled: boolean): {components_ty}
---@field tagged fun(self: {components_ty}, tag: string): {components_ty}
{f"---@field with_field fun(self: {components_ty}, field: {key_ty}, value: any): {components_ty}" if not empty else ""}
---@field add fun(self: {components_ty}, fields: {partial_ty}?): {component_ty}

{component_partial}

{component_full}

{fields}"""


def gen_component_types():
    types = "\n\n".join(
        gen_component_type(component_ty) for component_ty in components.keys()
    )

    open(OUT_DIR / "component_types.lua", "w").write(types)


gen_special_component_fields()
gen_component_types()
